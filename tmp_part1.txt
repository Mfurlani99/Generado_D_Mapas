}

function updateMarkerStyle(item) {
  if (item.marker) {
    item.marker.setIcon(makeDivIcon(item.type));
  }
}

async function geocodeAll(items) {
  const engine = (document.getElementById('geocoderEngine') && document.getElementById('geocoderEngine').value) || 'auto';
  // Limit concurrency to 1 for Nominatim, higher for others
  const concurrency = engine === 'nominatim' ? 1 : 5;
  let idx = 0;
  const worker = async () => {
    while (idx < items.length) {
      const i = idx++;
      await geocodeItem(items[i]);
    }
  };
  const workers = Array.from({ length: concurrency }, () => worker());
  await Promise.all(workers);
  fitToMarkers();
  updateLabelsThrottled();
}

async function geocodeItem(item) {
  item.status = 'pending';
  renderList();
  try {
    const restrict = document.getElementById('restrictComuna9').checked ? 'comuna9' : '';
    const engine = (document.getElementById('geocoderEngine') && document.getElementById('geocoderEngine').value) || 'auto';
    const url = `/api/geocode?q=${encodeURIComponent(item.raw)}${restrict ? `&restrict=${restrict}` : ''}&engine=${encodeURIComponent(engine)}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error('geocode http ' + res.status);
    const data = await res.json();
    if (Array.isArray(data) && data.length > 0) {
      const best = data[0];
      item.lat = parseFloat(best.lat);
      item.lon = parseFloat(best.lon);
      item.displayName = best.display_name || '';
      if (best.address) {
